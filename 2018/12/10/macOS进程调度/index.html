
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>macOS进程调度 | LAgagggggg&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="LAgagggggg">
    
    <meta name="description" content="&amp;emsp; macOS和Linux都是类Unix系统，与开源的Linux不同，macOS并不开源，但其类 Unix核心Darwin是开源的，在github上可以下载其源代码，这使我们可以一探其究竟。&amp;emsp; Darwin是基于XNU构建的，XNU就是macOS实际的内核了，与Linux相对应。">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/lagagggggg.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/lagagggggg.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="LAgagggggg&#39;s blog" title="LAgagggggg&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="LAgagggggg&#39;s blog">LAgagggggg&#39;s blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/12/10/macOS进程调度/" title="macOS进程调度" itemprop="url">macOS进程调度</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="LAgagggggg">LAgagggggg</a>
    </p>
  <p class="article-time">
    <time datetime="2018-12-09T17:04:14.000Z" itemprop="datePublished">2018-12-10</time>
    Updated:<time datetime="2018-12-21T07:53:25.896Z" itemprop="dateModified">2018-12-21</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#BSD-进程-Process"><span class="toc-number">1.</span> <span class="toc-text">BSD 进程 Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-任务-task"><span class="toc-number">2.</span> <span class="toc-text">Mach 任务 task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程调度"><span class="toc-number">3.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mach-线程调度"><span class="toc-number">3.1.</span> <span class="toc-text">Mach 线程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-调度器特性"><span class="toc-number">4.</span> <span class="toc-text">Mach 调度器特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#控制权转交"><span class="toc-number">4.1.</span> <span class="toc-text">控制权转交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用续体"><span class="toc-number">4.2.</span> <span class="toc-text">使用续体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步软件陷阱-Asynchronous-Software-Trap，AST"><span class="toc-number">4.3.</span> <span class="toc-text">异步软件陷阱 Asynchronous Software Trap，AST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上下文切换（content-switch）"><span class="toc-number">4.4.</span> <span class="toc-text">上下文切换（content switch）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级"><span class="toc-number">4.5.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级偏移"><span class="toc-number">4.6.</span> <span class="toc-text">优先级偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行队列"><span class="toc-number">4.7.</span> <span class="toc-text">运行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待队列"><span class="toc-number">4.8.</span> <span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-亲缘性"><span class="toc-number">4.9.</span> <span class="toc-text">CPU 亲缘性</span></a></li></ol></li></ol>
		</div>
		
		<p>&emsp; macOS和Linux都是类Unix系统，与开源的Linux不同，macOS并不开源，但其类 Unix核心Darwin是开源的，在github上可以下载其<a href="https://github.com/apple/darwin-xnu" target="_blank" rel="noopener">源代码</a>，这使我们可以一探其究竟。<br>&emsp; Darwin是基于XNU构建的，XNU就是macOS实际的内核了，与Linux相对应。不同的是Linux是宏内核结构而XNU是微内核结构，其差别见下面两幅图。</p>
<p><img src="http://pjq1ni60k.bkt.clouddn.com/20170625165537726.png" alt="20170625165537726"><br><img src="http://pjq1ni60k.bkt.clouddn.com/20170625165907363.png" alt="20170625165907363"></p>
<p>&emsp;XNU是混合式内核，是基于Mach和BSD内核构建的，这两个内核就是我们进行内存调度的主角。引用Apple的Github界面所述介绍一下什么是XNU:</p>
<blockquote>
<p>What is XNU?</p>
</blockquote>
<blockquote>
<p>XNU kernel is part of the Darwin operating system for use in macOS and iOS operating systems. XNU is an acronym for X is Not Unix. XNU is a hybrid kernel combining the Mach kernel developed at Carnegie Mellon University with components from FreeBSD and a C++ API for writing drivers called IOKit. XNU runs on x86_64 for both single processor and multi-processor configurations.</p>
</blockquote>
<p>&emsp;实际上，在XNU中Mach更接近于低层，BSD则建立于其上，XNU给用户态主要提供BSD的接口。在这样的结构下XNU是怎么进行进程调度的呢，这就要先介绍下BSD中进程和Mach中任务的概念。</p>
<h3 id="BSD-进程-Process"><a href="#BSD-进程-Process" class="headerlink" title="BSD 进程 Process"></a>BSD 进程 Process</h3><p>&emsp;BSD的进程可以唯一地映射到Mach 任务，但是包含的信息比Mach任务提供的基本调度和统计信息要丰富。BSD 进程包含了文件描述符和信号处理程序的数据。进程还支持复杂的谱系，将进程和其父进程、兄弟进程和子进程连接起来。BSD 在struct proc 中维护了进程的很多特性，有趣的是bsd的源代码中有这样一幅“图”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * vfork</span><br><span class="line"> *</span><br><span class="line"> * Description:	vfork system call</span><br><span class="line"> *</span><br><span class="line"> * Parameters:	void			[no arguments]</span><br><span class="line"> *</span><br><span class="line"> * Retval:	0			(to child process)</span><br><span class="line"> *		!0			pid of child (to parent process)</span><br><span class="line"> *		-1			error (see &quot;Returns:&quot;)</span><br><span class="line"> *</span><br><span class="line"> * Returns:	EAGAIN			Administrative limit reached</span><br><span class="line"> *		EINVAL			vfork() called during vfork()</span><br><span class="line"> *		ENOMEM			Failed to allocate new process</span><br><span class="line"> *</span><br><span class="line"> * Note:	After a successful call to this function, the parent process</span><br><span class="line"> *		has its task, thread, and uthread lent to the child process,</span><br><span class="line"> *		and control is returned to the caller; if this function is</span><br><span class="line"> *		invoked as a system call, the return is to user space, and</span><br><span class="line"> *		is effectively running on the child process.</span><br><span class="line"> *</span><br><span class="line"> *		Subsequent calls that operate on process state are permitted,</span><br><span class="line"> *		though discouraged, and will operate on the child process; any</span><br><span class="line"> *		operations on the task, thread, or uthread will result in</span><br><span class="line"> *		changes in the parent state, and, if inheritable, the child</span><br><span class="line"> *		state, when a task, thread, and uthread are realized for the</span><br><span class="line"> *		child process at execve() time, will also be effected.  Given</span><br><span class="line"> *		this, it&apos;s recemmended that people use the posix_spawn() call</span><br><span class="line"> *		instead.</span><br><span class="line"> *</span><br><span class="line"> * BLOCK DIAGRAM OF VFORK</span><br><span class="line"> *</span><br><span class="line"> * Before:</span><br><span class="line"> *</span><br><span class="line"> *     ,----------------.         ,-------------.</span><br><span class="line"> *     |                |   task  |             |</span><br><span class="line"> *     | parent_thread  | ------&gt; | parent_task |</span><br><span class="line"> *     |                | &lt;.list. |             |</span><br><span class="line"> *     `----------------&apos;         `-------------&apos;</span><br><span class="line"> *    uthread |  ^             bsd_info |  ^</span><br><span class="line"> *            v  | vc_thread            v  | task</span><br><span class="line"> *     ,----------------.         ,-------------.</span><br><span class="line"> *     |                |         |             |</span><br><span class="line"> *     | parent_uthread | &lt;.list. | parent_proc | &lt;-- current_proc()</span><br><span class="line"> *     |                |         |             |</span><br><span class="line"> *     `----------------&apos;         `-------------&apos;</span><br><span class="line"> *    uu_proc |</span><br><span class="line"> *            v</span><br><span class="line"> *           NULL</span><br><span class="line"> *</span><br><span class="line"> * After:</span><br><span class="line"> *</span><br><span class="line"> *                 ,----------------.         ,-------------.</span><br><span class="line"> *                 |                |   task  |             |</span><br><span class="line"> *          ,----&gt; | parent_thread  | ------&gt; | parent_task |</span><br><span class="line"> *          |      |                | &lt;.list. |             |</span><br><span class="line"> *          |      `----------------&apos;         `-------------&apos;</span><br><span class="line"> *          |     uthread |  ^             bsd_info |  ^</span><br><span class="line"> *          |             v  | vc_thread            v  | task</span><br><span class="line"> *          |      ,----------------.         ,-------------.</span><br><span class="line"> *          |      |                |         |             |</span><br><span class="line"> *          |      | parent_uthread | &lt;.list. | parent_proc |</span><br><span class="line"> *          |      |                |         |             |</span><br><span class="line"> *          |      `----------------&apos;         `-------------&apos;</span><br><span class="line"> *          |     uu_proc |  . list</span><br><span class="line"> *          |             v  v</span><br><span class="line"> *          |      ,----------------.</span><br><span class="line"> *          `----- |                |</span><br><span class="line"> *      p_vforkact | child_proc     | &lt;-- current_proc()</span><br><span class="line"> *                 |                |</span><br><span class="line"> *                 `----------------&apos;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="Mach-任务-task"><a href="#Mach-任务-task" class="headerlink" title="Mach 任务 task"></a>Mach 任务 task</h3><p>&emsp;Mach并不关心进程，而是使用了比进程更轻量级的概念：任务（task）。任务可以看作是一个机器无关的thread执行环境的抽象；或者一个包括虚拟地址空间、IPC空间、处理器资源、调度控制、thread的容器。<br>严格地说，Mach 的任务并不是其他操作系统中所谓的进程，因为Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只是提供了最基本的实现。任务是没有生命的。任务存在的目的就是称为一个或多个线程的容器。任务中的线程都在threads成员中维护，这是一个包含thread_count个线程的队列。此外，大部分对任务的操作实际上就是遍历给定任务中的所有线程，并对这些线程进行对应的线程操作。<br>task定义在osfmk/kern/task.h中，task结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">struct task &#123;</span><br><span class="line">	uint32_t		vtimers;</span><br><span class="line">#if defined(CONFIG_SCHED_MULTIQ)</span><br><span class="line">	sched_group_t sched_group;</span><br><span class="line">	queue_head_t		threads;</span><br><span class="line">	processor_set_t		pset_hint;</span><br><span class="line">	struct affinity_space	*affinity_space;</span><br><span class="line">	int			thread_count;</span><br><span class="line">	uint32_t		active_thread_count;</span><br><span class="line">	security_token_t sec_token;</span><br><span class="line">	audit_token_t	audit_token;</span><br><span class="line">	uint64_t		total_system_time;</span><br><span class="line">	uint64_t		total_ptime;</span><br><span class="line">	uint64_t		total_runnable_time;</span><br><span class="line">	decl_lck_mtx_data(,itk_lock_data)</span><br><span class="line">	struct exception_action exc_actions[EXC_TYPES_COUNT]; </span><br><span class="line">	struct ipc_port *itk_registered[TASK_PORT_REGISTER_MAX];</span><br><span class="line">	struct ipc_space *itk_space;</span><br><span class="line">	ledger_t	ledger;</span><br><span class="line">#define VM_BACKING_STORE_PRIV	0x1</span><br><span class="line">	MACHINE_TASK</span><br><span class="line">#ifdef  MACH_BSD </span><br><span class="line">	void *bsd_info;</span><br><span class="line">#endif  </span><br><span class="line">	kcdata_descriptor_t		corpse_info;</span><br><span class="line">	uint64_t			crashed_thread_id;</span><br><span class="line">	queue_chain_t			corpse_tasks;</span><br><span class="line">#ifdef CONFIG_MACF</span><br><span class="line">	struct label *			crash_label;</span><br><span class="line">#endif</span><br><span class="line">	struct vm_shared_region		*shared_region;</span><br><span class="line">#define TF_NONE                 0</span><br><span class="line"> * Task is running within a 64-bit address space.</span><br><span class="line">#define task_has_64Bit_addr(task)	</span><br><span class="line">	(((task)-&gt;t_flags &amp; TF_64B_ADDR) != 0)</span><br><span class="line">#define task_set_64Bit_addr(task)	</span><br><span class="line">	((task)-&gt;t_flags |= TF_64B_ADDR)</span><br><span class="line">#define task_clear_64Bit_addr(task)	</span><br><span class="line">	((task)-&gt;t_flags &amp;= ~TF_64B_ADDR)</span><br><span class="line">#define task_has_64Bit_data(task)	</span><br><span class="line">	(((task)-&gt;t_flags &amp; TF_64B_DATA) != 0)</span><br><span class="line">#define task_set_64Bit_data(task)	</span><br><span class="line">	((task)-&gt;t_flags |= TF_64B_DATA)</span><br><span class="line">#define task_clear_64Bit_data(task)	</span><br><span class="line">	((task)-&gt;t_flags &amp;= ~TF_64B_DATA)</span><br><span class="line">#define task_is_a_corpse(task)      </span><br><span class="line">	 (((task)-&gt;t_flags &amp; TF_CORPSE) != 0)</span><br><span class="line">#define task_set_corpse(task)       </span><br><span class="line">	 ((task)-&gt;t_flags |= TF_CORPSE)</span><br><span class="line">#define task_corpse_pending_report(task) 	</span><br><span class="line">	 (((task)-&gt;t_flags &amp; TF_PENDING_CORPSE) != 0)</span><br><span class="line">#define task_set_corpse_pending_report(task)       </span><br><span class="line">	 ((task)-&gt;t_flags |= TF_PENDING_CORPSE)</span><br><span class="line">#define task_clear_corpse_pending_report(task)       </span><br><span class="line">	 ((task)-&gt;t_flags &amp;= ~TF_PENDING_CORPSE)</span><br><span class="line">#define task_is_a_corpse_fork(task)	</span><br><span class="line">	(((task)-&gt;t_flags &amp; TF_CORPSE_FORK) != 0)</span><br><span class="line">#define TPF_NONE                 0</span><br><span class="line">#ifdef CONFIG_32BIT_TELEMETRY</span><br><span class="line">#endif</span><br><span class="line">#define task_did_exec_internal(task)		</span><br><span class="line">	(((task)-&gt;t_procflags &amp; TPF_DID_EXEC) != 0)</span><br><span class="line">#define task_is_exec_copy_internal(task)	</span><br><span class="line">	(((task)-&gt;t_procflags &amp; TPF_EXEC_COPY) != 0)</span><br><span class="line">#if KPC</span><br><span class="line">	uint16_t policy_ru_cpu          :4,</span><br><span class="line">	         policy_ru_cpu_ext      :4,</span><br><span class="line">	         applied_ru_cpu         :4,</span><br><span class="line">	         applied_ru_cpu_ext     :4;</span><br><span class="line">	uint8_t  rusage_cpu_flags;</span><br><span class="line">#if MACH_ASSERT</span><br><span class="line">#endif</span><br><span class="line">	uint64_t rusage_cpu_deadline;</span><br><span class="line">	thread_call_t rusage_cpu_callt;</span><br><span class="line">#if CONFIG_EMBEDDED</span><br><span class="line">	int	num_taskwatchers;</span><br><span class="line">	int		watchapplying;</span><br><span class="line"></span><br><span class="line">#if CONFIG_ATM</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if IMPORTANCE_INHERITANCE</span><br><span class="line"></span><br><span class="line">	vm_extmod_statistics_data_t	extmod_statistics;</span><br><span class="line"></span><br><span class="line">	struct task_requested_policy requested_policy;</span><br><span class="line">	struct task_effective_policy effective_policy;</span><br><span class="line">	 * Can be merged with imp_donor bits, once the IMPORTANCE_INHERITANCE macro goes away.</span><br><span class="line">	io_stat_info_t 		task_io_stats;</span><br><span class="line">	uint64_t 		task_immediate_writes __attribute__((aligned(8)));</span><br><span class="line">	uint64_t 		task_deferred_writes __attribute__((aligned(8)));</span><br><span class="line">	uint64_t 		task_invalidated_writes __attribute__((aligned(8)));</span><br><span class="line">	uint64_t 		task_metadata_writes __attribute__((aligned(8)));</span><br><span class="line">	 * The cpu_time_qos_stats fields are protected by the task lock</span><br><span class="line">	struct _cpu_time_qos_stats 	cpu_time_eqos_stats;</span><br><span class="line">	struct _cpu_time_qos_stats 	cpu_time_rqos_stats;</span><br><span class="line"></span><br><span class="line">	uint32_t	task_timer_wakeups_bin_1;</span><br><span class="line">	uint32_t	task_timer_wakeups_bin_2;</span><br><span class="line">	uint64_t	task_gpu_ns;</span><br><span class="line">	uint64_t	task_energy;</span><br><span class="line">#if MONOTONIC</span><br><span class="line">	struct mt_task task_monotonic;</span><br><span class="line">	int		task_volatile_objects;</span><br><span class="line">	int		task_nonvolatile_objects;</span><br><span class="line">	boolean_t	task_purgeable_disowning;</span><br><span class="line">	boolean_t	task_purgeable_disowned;</span><br><span class="line">	queue_head_t	task_objq;</span><br><span class="line">	unsigned int	task_thread_limit:16;</span><br><span class="line">#if __arm64__</span><br><span class="line">	unsigned int	task_legacy_footprint:1;</span><br><span class="line">	unsigned int	task_region_footprint:1;</span><br><span class="line">	unsigned int	task_has_crossed_thread_limit:1;</span><br><span class="line">	uint32_t	exec_token;</span><br><span class="line">	coalition_t	coalition[COALITION_NUM_TYPES];</span><br><span class="line">	queue_chain_t   task_coalition[COALITION_NUM_TYPES];</span><br><span class="line">	uint64_t        dispatchqueue_offset;</span><br><span class="line">#if DEVELOPMENT || DEBUG</span><br><span class="line">	boolean_t	task_unnested;</span><br><span class="line">	int		task_disconnected_count;</span><br><span class="line">#endif</span><br><span class="line">#if HYPERVISOR</span><br><span class="line">#if CONFIG_SECLUDED_MEMORY</span><br><span class="line">	uint8_t	task_can_use_secluded_mem;</span><br><span class="line">	uint8_t	task_could_use_secluded_mem;</span><br><span class="line">	uint8_t	task_could_also_use_secluded_mem;</span><br><span class="line">	uint8_t	task_suppressed_secluded;</span><br><span class="line">	uint32_t task_exc_guard;</span><br><span class="line">	queue_head_t    io_user_clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###线程 Thread<br>&emsp;与Linux不同，XNU是有真正的线程的。<br>&emsp;线程是利用CPU的基本单位，进程是占有资源的基本单位。为了最大化利用进程时间片的方法，引入线程的概念。通过使用多个线程，程序的指向可以分割表面上看上去并发执行的子任务。线程之间切换的开销比较小，只要保存和恢复寄存器即可。多核处理器更是特别和适合线程，因为多个处理器核心共享同样的cache和ARM，为线程间的共享虚拟内存提供了基础。一般一个进程会包括多个线程。<br>&emsp;线程是Mach中的最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据。线程从设计上提供了所需要的大量信息，同时又尽可能地维持最小开销。<br>在Mach中线程的数据结构非常巨大，因此大部分的线程创建时都是从一个通用的模板复制而来的，这个模板使用默认值填充这个数据结构，这个模板名为thread_template，内核引导过程中被调用的thread_bootstrap( )负责填充这个模板。thread_create_internal( )函数分配新的线程数据结构，然后将换这个模板的内容负责到新的线程数据结构中。<br>Mach API thread_create( ) 就是通过thread_create_internal( )实现的。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>&emsp;上述BSD的Process和Mach的Task在进行调度时是一对一的映射关系，每一个BSD进程都在底层关联了一个Mach任务对象。实现这种映射的方法是指定一个透明的指针bsd_info，Mach 对bsd_info 完全无知。实际的调度大多数是由Mach通过操作Task来完成。<br><img src="http://pjq1ni60k.bkt.clouddn.com/11121345_Zw5P.png" alt="11121345_Zw5P"></p>
<p>&emsp;现在面向用户的操作系统基本上都采用抢占式调度方式,macOS当然也是。主要的抢占原则有：</p>
<ul>
<li>优先权原则</li>
<li>短作业优先原则</li>
<li>时间片原则</li>
</ul>
<p>&emsp;其进程状态切换大致如下图所示<br><img src="http://pjq1ni60k.bkt.clouddn.com/4367959-d40eee18c58e54cc.png" alt="4367959-d40eee18c58e54c"></p>
<p>首先系统会调用task_create_internal()创建一个进程，创建完成后task会被加入运行队列。之后就由kern_sig发出信号对进程进行轮转调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">task_create_internal(</span><br><span class="line">	task_t		parent_task,</span><br><span class="line">	coalition_t	*parent_coalitions __unused,</span><br><span class="line">	boolean_t	inherit_memory,</span><br><span class="line">	__unused boolean_t	is_64bit,</span><br><span class="line">	boolean_t is_64bit_data,</span><br><span class="line">	uint32_t	t_flags,</span><br><span class="line">	uint32_t	t_procflags,</span><br><span class="line">	task_t		*child_task)	</span><br><span class="line">&#123;</span><br><span class="line">	task_t			new_task;</span><br><span class="line">	vm_shared_region_t	shared_region;</span><br><span class="line">	ledger_t		ledger = NULL;</span><br><span class="line">	new_task = (task_t) zalloc(task_zone);</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">	ipc_task_enable(new_task);</span><br><span class="line">	lck_mtx_lock(&amp;tasks_threads_lock);</span><br><span class="line">	queue_enter(&amp;tasks, new_task, task_t, tasks);</span><br><span class="line">	tasks_count++;</span><br><span class="line">        if (tasks_suspend_state) &#123;</span><br><span class="line">            task_suspend_internal(new_task);</span><br><span class="line">        &#125;</span><br><span class="line">	lck_mtx_unlock(&amp;tasks_threads_lock);</span><br><span class="line"></span><br><span class="line">	*child_task = new_task;</span><br><span class="line">	return(KERN_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mach-线程调度"><a href="#Mach-线程调度" class="headerlink" title="Mach 线程调度"></a>Mach 线程调度</h4><p>Mach 的线程调度算法高度可扩展。通常情况下，Mach只启用了一个调度器。但是Mach的架构运行定义额外的调度器，并且在编译时根据CONFIG_SCHED_的定义设置调度器。每一个调度器对象都维护一个sched_dispatch_table 数据结构，其中以函数指针的方式保存了各种操作,主要的调度操作都要依靠sched_dispatch_table 来完成。Mach使用一个全局表sched_current_dispatch 保存了当前活动的调度算法，并允许运行时切换调度器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">struct sched_dispatch_table &#123;</span><br><span class="line">	const char *sched_name;</span><br><span class="line">	void	(*init)(void);				/* Init global state */</span><br><span class="line">	void	(*timebase_init)(void);		/* Timebase-dependent initialization */</span><br><span class="line">	void	(*processor_init)(processor_t processor);	/* Per-processor scheduler init */</span><br><span class="line">	void	(*pset_init)(processor_set_t pset);	/* Per-processor set scheduler init */</span><br><span class="line"></span><br><span class="line">	void	(*maintenance_continuation)(void);	/* Function called regularly */</span><br><span class="line">	thread_t	(*choose_thread)(</span><br><span class="line">								  processor_t		processor,</span><br><span class="line">								  int				priority,</span><br><span class="line">								  ast_t reason);</span><br><span class="line"></span><br><span class="line">	boolean_t   steal_thread_enabled;</span><br><span class="line">	thread_t	(*steal_thread)(</span><br><span class="line">								processor_set_t		pset);</span><br><span class="line">	int (*compute_timeshare_priority)(thread_t thread);</span><br><span class="line">	processor_t	(*choose_processor)(</span><br><span class="line">										 processor_set_t		pset,</span><br><span class="line">										 processor_t			processor,</span><br><span class="line">										 thread_t			thread);</span><br><span class="line">	boolean_t (*processor_enqueue)(</span><br><span class="line">								 processor_t			processor,</span><br><span class="line">								 thread_t			thread,</span><br><span class="line">								 integer_t			options);</span><br><span class="line"></span><br><span class="line">	void (*processor_queue_shutdown)(</span><br><span class="line">									 processor_t			processor);</span><br><span class="line"></span><br><span class="line">	boolean_t	(*processor_queue_remove)(</span><br><span class="line">									processor_t		processor,</span><br><span class="line">									thread_t		thread);</span><br><span class="line"></span><br><span class="line">	boolean_t	(*processor_queue_empty)(processor_t		processor);</span><br><span class="line">	boolean_t	(*priority_is_urgent)(int priority);</span><br><span class="line">	ast_t		(*processor_csw_check)(processor_t processor);</span><br><span class="line">	boolean_t	(*processor_queue_has_priority)(processor_t		processor,</span><br><span class="line">												int				priority,</span><br><span class="line">												boolean_t		gte);</span><br><span class="line"></span><br><span class="line">	uint32_t	(*initial_quantum_size)(thread_t thread);</span><br><span class="line">	sched_mode_t	(*initial_thread_sched_mode)(task_t parent_task);</span><br><span class="line">	boolean_t	(*can_update_priority)(thread_t thread);</span><br><span class="line">	void		(*update_priority)(thread_t thread);</span><br><span class="line">	void		(*lightweight_update_priority)(thread_t thread);</span><br><span class="line">	void		(*quantum_expire)(thread_t thread);Runnable threads on per-processor runqueue. Should onlybe used for relative comparisons of load between processors.</span><br><span class="line">	int			(*processor_runq_count)(processor_t	processor);</span><br><span class="line">	uint64_t    (*processor_runq_stats_count_sum)(processor_t   processor);</span><br><span class="line">	boolean_t	(*processor_bound_count)(processor_t processor);</span><br><span class="line">	void		(*thread_update_scan)(sched_update_scan_context_t scan_context);</span><br><span class="line">	boolean_t   direct_dispatch_to_idle_processors;</span><br><span class="line">	boolean_t   multiple_psets_enabled;</span><br><span class="line">	boolean_t   sched_groups_enabled;</span><br><span class="line">	boolean_t   avoid_processor_enabled;</span><br><span class="line">	bool    (*thread_avoid_processor)(processor_t processor, thread_t thread);</span><br><span class="line">	void    (*processor_balance)(processor_t processor, processor_set_t pset);</span><br><span class="line">	rt_queue_t	(*rt_runq)(processor_set_t pset);</span><br><span class="line">	void	(*rt_init)(processor_set_t pset);</span><br><span class="line">	void	(*rt_queue_shutdown)(processor_t processor);</span><br><span class="line">	void	(*rt_runq_scan)(sched_update_scan_context_t scan_context);</span><br><span class="line">	int64_t	(*rt_runq_count_sum)(void);</span><br><span class="line"></span><br><span class="line">	uint32_t (*qos_max_parallelism)(int qos, uint64_t options);</span><br><span class="line">	void	(*check_spill)(processor_set_t pset, thread_t thread);</span><br><span class="line">	sched_ipi_type_t (*ipi_policy)(processor_t dst, thread_t thread, boolean_t dst_idle, sched_ipi_event_t event);</span><br><span class="line">	bool    (*thread_should_yield)(processor_t processor, thread_t thread);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当调用thread_create_internal()创建一个线程时，其内部会设置线程的调度策略和优先级，并将其加入任务队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Set the thread&apos;s scheduling parameters */</span><br><span class="line">	new_thread-&gt;sched_mode = SCHED(initial_thread_sched_mode)(parent_task);</span><br><span class="line">	new_thread-&gt;max_priority = parent_task-&gt;max_priority;</span><br><span class="line">	new_thread-&gt;task_priority = parent_task-&gt;priority;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Chain the thread onto the task&apos;s list */</span><br><span class="line">	queue_enter(&amp;parent_task-&gt;threads, new_thread, thread_t, task_threads);</span><br><span class="line">	parent_task-&gt;thread_count++;</span><br></pre></td></tr></table></figure>
<p>接下来调度器就会在收到kernel event(比如时间片轮转)时，调用thread_wakeup_prim()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	thread_wakeup_prim:</span><br><span class="line"> *</span><br><span class="line"> *	Common routine for thread_wakeup, thread_wakeup_with_result,</span><br><span class="line"> *	and thread_wakeup_one.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">kern_return_t thread_wakeup_prim(</span><br><span class="line">                   event_t          event,</span><br><span class="line">                   boolean_t        one_thread,</span><br><span class="line">                   wait_result_t    result)</span><br><span class="line">&#123;</span><br><span class="line">	if (__improbable(event == NO_EVENT))</span><br><span class="line">		panic(&quot;%s() called with NO_EVENT&quot;, __func__);</span><br><span class="line"></span><br><span class="line">	struct waitq *wq = global_eventq(event);</span><br><span class="line"></span><br><span class="line">	if (one_thread)</span><br><span class="line">		return waitq_wakeup64_one(wq, CAST_EVENT64_T(event), result, WAITQ_ALL_PRIORITIES);</span><br><span class="line">	else</span><br><span class="line">		return waitq_wakeup64_all(wq, CAST_EVENT64_T(event), result, WAITQ_ALL_PRIORITIES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来则会进入等待队列(waitq.c)，调用waitq_wakeup64_one()唤醒一个线程。而在waitq_wakeup64_one中会实际调用waitq_wakeup64_one_locked()，可以看到这里会调用waitq_select_max_locked()选择一个优先级最高的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t waitq_wakeup64_one_locked(struct waitq *waitq,</span><br><span class="line">					event64_t wake_event,</span><br><span class="line">					wait_result_t result,</span><br><span class="line">					uint64_t *reserved_preposts,</span><br><span class="line">					int priority,</span><br><span class="line">					waitq_lock_state_t lock_state)</span><br><span class="line">&#123;</span><br><span class="line">	thread_t thread;</span><br><span class="line">	spl_t th_spl;</span><br><span class="line"></span><br><span class="line">	assert(waitq_held(waitq));</span><br><span class="line"></span><br><span class="line">	if (priority == WAITQ_SELECT_MAX_PRI) &#123;</span><br><span class="line">		thread = waitq_select_max_locked(waitq, wake_event,</span><br><span class="line">		                                 reserved_preposts,</span><br><span class="line">		                                 &amp;th_spl);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		thread = waitq_select_one_locked(waitq, wake_event,</span><br><span class="line">		                                 reserved_preposts,</span><br><span class="line">		                                 priority, &amp;th_spl);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (thread != THREAD_NULL)</span><br><span class="line">		waitq_stats_count_wakeup(waitq);</span><br><span class="line">	else</span><br><span class="line">		waitq_stats_count_fail(waitq);</span><br><span class="line"></span><br><span class="line">	if (lock_state == WAITQ_UNLOCK)</span><br><span class="line">		waitq_unlock(waitq);</span><br><span class="line"></span><br><span class="line">	if (thread != THREAD_NULL) &#123;</span><br><span class="line">		maybe_adjust_thread_pri(thread, priority, waitq);</span><br><span class="line">		kern_return_t ret = thread_go(thread, result);</span><br><span class="line">		assert(ret == KERN_SUCCESS);</span><br><span class="line">		thread_unlock(thread);</span><br><span class="line">		splx(th_spl);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return KERN_NOT_WAITING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实不管调用的是哪些方法最后都会来到do_waitq_select_n_locked(),在这里面会进行实际的解锁线程的操作，比如调用thread_clear_waitq_state()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">static void do_waitq_select_n_locked(struct waitq_select_args *args)</span><br><span class="line">&#123;</span><br><span class="line">	struct waitq *waitq = args-&gt;waitq;</span><br><span class="line">	int max_threads = args-&gt;max_threads;</span><br><span class="line">	thread_t first_thread = THREAD_NULL;</span><br><span class="line">	struct waitq *safeq;</span><br><span class="line">	uint32_t remaining_eventmask = 0;</span><br><span class="line">	uint32_t eventmask;</span><br><span class="line">	int *nthreads = args-&gt;nthreads;</span><br><span class="line">	spl_t spl = 0;</span><br><span class="line"></span><br><span class="line">	assert(max_threads != 0);</span><br><span class="line"></span><br><span class="line">	if (!waitq_irq_safe(waitq)) &#123;</span><br><span class="line">		/* JMM - add flag to waitq to avoid global lookup if no waiters */</span><br><span class="line">		eventmask = _CAST_TO_EVENT_MASK(waitq);</span><br><span class="line">		safeq = waitq_get_safeq(waitq);</span><br><span class="line">		if (*nthreads == 0)</span><br><span class="line">			spl = splsched();</span><br><span class="line">		waitq_lock(safeq);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		eventmask = _CAST_TO_EVENT_MASK(args-&gt;event);</span><br><span class="line">		safeq = waitq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If the safeq doesn&apos;t have an eventmask (not global) or the event</span><br><span class="line">	 * we&apos;re looking for IS set in its eventmask, then scan the threads</span><br><span class="line">	 * in that queue for ones that match the original &lt;waitq,event&gt; pair.</span><br><span class="line">	 */</span><br><span class="line">	if (!waitq_is_global(safeq) ||</span><br><span class="line">	    (safeq-&gt;waitq_eventmask &amp; eventmask) == eventmask) &#123;</span><br><span class="line"></span><br><span class="line">		if (waitq_is_turnstile_queue(safeq)) &#123;</span><br><span class="line">			first_thread = waitq_prioq_iterate_locked(safeq, waitq,</span><br><span class="line">								  spl, args,</span><br><span class="line">								  &amp;remaining_eventmask);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			first_thread = waitq_queue_iterate_locked(safeq, waitq,</span><br><span class="line">								  spl, args,</span><br><span class="line">								  &amp;remaining_eventmask);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * Update the eventmask of global queues we just scanned:</span><br><span class="line">		 * - If we selected all the threads in the queue, we can clear its</span><br><span class="line">		 *   eventmask.</span><br><span class="line">		 *</span><br><span class="line">		 * - If we didn&apos;t find enough threads to fill our needs, then we can</span><br><span class="line">		 *   assume we looked at every thread in the queue and the mask we</span><br><span class="line">		 *   computed is complete - so reset it.</span><br><span class="line">		 */</span><br><span class="line">		if (waitq_is_global(safeq)) &#123;</span><br><span class="line">			if (waitq_empty(safeq))</span><br><span class="line">				safeq-&gt;waitq_eventmask = 0;</span><br><span class="line">			else if (max_threads &lt; 0 || *nthreads &lt; max_threads)</span><br><span class="line">				safeq-&gt;waitq_eventmask = remaining_eventmask;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Grab the first thread in the queue if no other thread was selected.</span><br><span class="line">	 * We can guarantee that no one has manipulated this thread because</span><br><span class="line">	 * it&apos;s waiting on the given waitq, and we have that waitq locked.</span><br><span class="line">	 */</span><br><span class="line">	if (*nthreads == 0 &amp;&amp; first_thread != THREAD_NULL &amp;&amp; args-&gt;threadq) &#123;</span><br><span class="line">		/* we know this is the first (and only) thread */</span><br><span class="line">		++(*nthreads);</span><br><span class="line">		*(args-&gt;spl) = (safeq != waitq) ? spl : splsched();</span><br><span class="line">		thread_lock(first_thread);</span><br><span class="line">		thread_clear_waitq_state(first_thread);</span><br><span class="line">		waitq_thread_remove(safeq, first_thread);</span><br><span class="line">		enqueue_tail(args-&gt;threadq, &amp;(first_thread-&gt;wait_links));</span><br><span class="line"></span><br><span class="line">		/* update the eventmask on [now] empty global queues */</span><br><span class="line">		if (waitq_is_global(safeq) &amp;&amp; waitq_empty(safeq))</span><br><span class="line">			safeq-&gt;waitq_eventmask = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* unlock the safe queue if we locked one above */</span><br><span class="line">	if (safeq != waitq) &#123;</span><br><span class="line">		waitq_unlock(safeq);</span><br><span class="line">		if (*nthreads == 0)</span><br><span class="line">			splx(spl);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	if (max_threads &gt; 0 &amp;&amp; *nthreads &gt;= max_threads)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * wait queues that are not in any sets</span><br><span class="line">	 * are the bottom of the recursion</span><br><span class="line">	 */</span><br><span class="line">	if (!waitq-&gt;waitq_set_id)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	/* check to see if the set ID for this wait queue is valid */</span><br><span class="line">	struct waitq_link *link = wql_get_link(waitq-&gt;waitq_set_id);</span><br><span class="line">	if (!link) &#123;</span><br><span class="line">		/* the waitq set to which this waitq belonged, has been invalidated */</span><br><span class="line">		waitq-&gt;waitq_set_id = 0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wql_put_link(link);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this waitq is a member of any wait queue sets, we need to look</span><br><span class="line">	 * for waiting thread(s) in any of those sets, and prepost all sets that</span><br><span class="line">	 * don&apos;t have active waiters.</span><br><span class="line">	 *</span><br><span class="line">	 * Note that we do a local walk of this waitq&apos;s links - we manually</span><br><span class="line">	 * recurse down wait queue set&apos;s with non-zero wqset_q.waitq_set_id</span><br><span class="line">	 */</span><br><span class="line">	(void)walk_waitq_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,</span><br><span class="line">			       WQL_WQS, (void *)args, waitq_select_walk_cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mach-调度器特性"><a href="#Mach-调度器特性" class="headerlink" title="Mach 调度器特性"></a>Mach 调度器特性</h3><h4 id="控制权转交"><a href="#控制权转交" class="headerlink" title="控制权转交"></a>控制权转交</h4><p>Mach允许一个线程主动放弃CPU，但不是将CPU放弃给任何其他线程，而是将CPU转交给自己选择的某个特定的线程。由于Mach 是一个基于消息传递的内核，线程之间通过消息传递通讯，所以这项特性在Mach 中特别有用。通过这个特性，消息的处理延迟可以达到最小，而不需要投机地等待消息处理线程（发送者或接收者）下一次得到调度。这个特性是Mach特有的。</p>
<h4 id="使用续体"><a href="#使用续体" class="headerlink" title="使用续体"></a>使用续体</h4><p>续体（continuation）是计算机程序的控制状态的一种抽象表现。 实化了程序状态信息。可以理解为，一个计算续体以数据结构的形式表现了程序在运行过程中某一点的计算状态，相应的数据内容可以被编程语言访问，而不是被运行时环境所隐藏掉。<br>使用续体可以使线程不用管理自己的栈，线程可以丢弃自己的栈，系统恢复线程执行时不需要恢复线程的栈。续体是缓解上下文切换开销的简单有效的机制。这个特性是Mach特有的。</p>
<h4 id="异步软件陷阱-Asynchronous-Software-Trap，AST"><a href="#异步软件陷阱-Asynchronous-Software-Trap，AST" class="headerlink" title="异步软件陷阱 Asynchronous Software Trap，AST"></a>异步软件陷阱 Asynchronous Software Trap，AST</h4><p>异步软件陷阱是软件对底层硬件陷阱机制的补充完善，通过使用AST，内核可以响应需要得到关注的out-off-band事件，例如调度事件。<br>AST是人工引发的非硬件触发的陷阱。AST是内核操作的关键部分，而且是调度时间的底层机制，也是BSD信号的实现基础。AST实现为线程控制块中一个包含各种标志位的字段，这些标志位可以通过thread_ast_set（ ）分别设置。这个特性是Mach特有的。</p>
<h4 id="上下文切换（content-switch）"><a href="#上下文切换（content-switch）" class="headerlink" title="上下文切换（content switch）"></a>上下文切换（content switch）</h4><p>上下文切换是暂停某个线程的执行，并且将其寄存器状态记录在某个预定义的内存位置中。寄存器状态是和及其相关的。当一个线程被抢占时，CPU 寄存器中会价值另一个线程保存的线程状态，从而恢复到那个线程的执行。<br>一个线程在CPU上可以执行任意长的时间。执行（execute）指的是这样的一个事实：CPU 寄存器中填满了线程的状态，因此CPU（通过EIP/RIP指令指针或PC程序计数器）执行该线程函数的代码。这个执行会一直持续，直到发生下面某种情况：</p>
<ul>
<li>线程终止</li>
<li>线程自愿放弃</li>
<li>外部中断打断了线程的执行，外部中断要求CPU 保存线程状态并且立即执行中断处理代码</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>每一个Mach线程都包含优先级信息，优先级直接影响线程被调度的频率。Mach 有128个优先级。<br>内核线程的最低优先级为80，比用户态线程的优先级要高。可以保证内核以及用户维护管理的线程能够抢占用户态的线程。优先级主要在osfmk/kern/sched.h中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	High-level priority assignments</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************</span><br><span class="line"> * 127		Reserved (real-time)</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(32 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 96		Reserved (real-time)</span><br><span class="line"> * 95		Kernel mode only</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(16 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 80		Kernel mode only</span><br><span class="line"> * 79		System high priority</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(16 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 64		System high priority</span><br><span class="line"> * 63		Elevated priorities</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(12 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 52		Elevated priorities</span><br><span class="line"> * 51		Elevated priorities (incl. BSD +nice)</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(20 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 32		Elevated priorities (incl. BSD +nice)</span><br><span class="line"> * 31		Default (default base for threads)</span><br><span class="line"> * 30		Lowered priorities (incl. BSD -nice)</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(20 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 11		Lowered priorities (incl. BSD -nice)</span><br><span class="line"> * 10		Lowered priorities (aged pri&apos;s)</span><br><span class="line"> *				A</span><br><span class="line"> *				+</span><br><span class="line"> *			(11 levels)</span><br><span class="line"> *				+</span><br><span class="line"> *				V</span><br><span class="line"> * 0		Lowered priorities (aged pri&apos;s / idle)</span><br><span class="line"> *************************************************************************</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h4 id="优先级偏移"><a href="#优先级偏移" class="headerlink" title="优先级偏移"></a>优先级偏移</h4><p>给线程分配优先级只是一个开头，这些优先级在运行时常常需要调整。Mach 会针对每一个线程的CPU 利用率和整体系统负载动态调整每一个线程的优先级。</p>
<h4 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h4><p>线程是通过运行队列管理的。 运行队列是一个多层列表，即一个列表的数组，针对128个优先级中的每一个优先级都要一个队列。Mach 实际采用的方法是检查位图，这样就可以同时检查32个队列，这样时间复杂度为O(4)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct run_queue &#123;</span><br><span class="line">	int					highq;				/* highest runnable queue */</span><br><span class="line">	bitmap_t				bitmap[BITMAP_LEN(NRQS)];	/* run queue bitmap array */</span><br><span class="line">	int					count;				/* # of threads total */</span><br><span class="line">	int					urgency;			/* level of preemption urgency */</span><br><span class="line">	queue_head_t		queues[NRQS];		/* one for each priority */</span><br><span class="line"></span><br><span class="line">	struct runq_stats	runq_stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>当进程或者线程阻塞，就没有必要考虑调度这个线程，因为只有当线程等待的对象或I/O 操作完成或时间发生时才能继续执行。所以可以将线程放在等待队列中。当等待的条件满足之后，一个或多个等待的线程可以被解除阻塞并且再次分发执行。</p>
<h4 id="CPU-亲缘性"><a href="#CPU-亲缘性" class="headerlink" title="CPU 亲缘性"></a>CPU 亲缘性</h4><p>在使用多核、SMP 或 超线程的现代架构中，还可以设置某个线程和一个或多个指定CPU 的亲缘性（affinity）。这种亲缘性对于线程和系统来说都是有好处的，因为当线程回到同一个CPU上执行时，线程的数据可能还留在CPU的缓存中，从而提升性能。<br>在Mach中，线程对CPU 的亲缘性的意思就是绑定。thread_bind( )的目的就是绑定线程，这个函数仅仅是更新thread_t的bound_processor字段。如果这个字段被设置为PROCESSOR_NULL之外的任何值，那么未来的调度策略就会将这个线程分发到对应处理器的运行队列。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/macOS/">macOS</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2018/12/10/macOS进程调度/" data-title="macOS进程调度 | LAgagggggg&#39;s blog" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/01/16/2019-01-16/" title="">
  <strong>PREVIOUS:</strong><br/>
  <span>
  (no title)</span>
</a>
</div>


<div class="next">
<a href="/2018/10/01/iOS学习资料搜集/"  title="iOS学习资料搜集">
 <strong>NEXT:</strong><br/> 
 <span>iOS学习资料搜集
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#BSD-进程-Process"><span class="toc-number">1.</span> <span class="toc-text">BSD 进程 Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-任务-task"><span class="toc-number">2.</span> <span class="toc-text">Mach 任务 task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程调度"><span class="toc-number">3.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mach-线程调度"><span class="toc-number">3.1.</span> <span class="toc-text">Mach 线程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mach-调度器特性"><span class="toc-number">4.</span> <span class="toc-text">Mach 调度器特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#控制权转交"><span class="toc-number">4.1.</span> <span class="toc-text">控制权转交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用续体"><span class="toc-number">4.2.</span> <span class="toc-text">使用续体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步软件陷阱-Asynchronous-Software-Trap，AST"><span class="toc-number">4.3.</span> <span class="toc-text">异步软件陷阱 Asynchronous Software Trap，AST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上下文切换（content-switch）"><span class="toc-number">4.4.</span> <span class="toc-text">上下文切换（content switch）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级"><span class="toc-number">4.5.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先级偏移"><span class="toc-number">4.6.</span> <span class="toc-text">优先级偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行队列"><span class="toc-number">4.7.</span> <span class="toc-text">运行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等待队列"><span class="toc-number">4.8.</span> <span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-亲缘性"><span class="toc-number">4.9.</span> <span class="toc-text">CPU 亲缘性</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/iOS/" title="iOS">iOS<sup>4</sup></a></li>
		
			<li><a href="/tags/iOSRE/" title="iOSRE">iOSRE<sup>2</sup></a></li>
		
			<li><a href="/tags/macOS/" title="macOS">macOS<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
      <!-- <li><a href="http://blog.codedragon.tech" target="_blank" title="CoSidian">CoSidian</a></li> -->
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2019 
		
		<a href="http://yoursite.com" target="_blank" title="LAgagggggg">LAgagggggg</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:""};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
